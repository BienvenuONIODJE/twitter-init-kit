# Research & Architecture Decisions: Twitter-Init-Kit Foundation

**Date**: 2025-12-04
**Status**: Foundation Phase
**Related Docs**: [spec.md](./spec.md) | [plan.md](./plan.md) | [tasks.md](./tasks.md)

---

## 1. Multi-Kit Coexistence Architecture

### 1.1 Problem Statement

Multiple `*-kit` variants (spec-kit, twitter-kit, pm-kit, pd-kit, blog-kit) need to coexist on the same machine and potentially within the same project without conflicts.

**Key Collision Points:**
1. **Package Folder Names**: `.specify/` could collide between kits
2. **CLI Command Names**: `specify` command could be ambiguous
3. **Slash Command Names**: `/specify`, `/plan`, `/tasks` could conflict
4. **Python Package Names**: `specify_cli` could conflict in installed tools

### 1.2 Namespace Strategy (ADOPTED)

We implement a **three-level namespace isolation** strategy:

#### Level 1: Package Folder Isolation

**Pattern**: Each kit uses a unique `.{kitname}/` folder

| Kit | Package Folder | Example |
|-----|----------------|---------|
| spec-kit | `.specify/` | `.specify/memory/constitution.md` |
| twitter-kit | `.twitterkit/` | `.twitterkit/memory/constitution.md` |
| pm-kit | `.pmkit/` | `.pmkit/memory/constitution.md` |
| pd-kit | `.pdkit/` | `.pdkit/memory/constitution.md` |
| blog-kit | `.blogkit/` | `.blogkit/memory/constitution.md` |

**Benefits:**
- Multiple kits can coexist in same project directory
- Clear separation of domain-specific content
- Git-friendly (each kit's folder is independently trackable)

#### Level 2: CLI Command Isolation

**Pattern**: Each kit has a unique CLI command name

| Kit | CLI Command | PyPI Package | Entry Point |
|-----|-------------|--------------|-------------|
| spec-kit | `specify` | `specify-cli` | `specify_cli:main` |
| twitter-kit | `twitterify` | `twitterify-cli` | `twitterify_cli:main` |
| pm-kit | `pmify` | `pmify-cli` | `pmify_cli:main` |
| pd-kit | `pdify` | `pdify-cli` | `pdify_cli:main` |
| blog-kit | `blogify` | `blogify-cli` | `blogify_cli:main` |

**Benefits:**
- No command name conflicts when multiple kits installed globally
- Clear intent (e.g., `twitterify init` vs `specify init`)
- Consistent naming pattern (`{domain}ify`)

#### Level 3: Slash Command Namespacing

**Pattern**: Each kit prefixes slash commands with `/{kitname}.*`

| Kit | Slash Command Prefix | Examples |
|-----|---------------------|----------|
| spec-kit | `/speckit.*` | `/speckit.specify`, `/speckit.plan`, `/speckit.tasks` |
| twitter-kit | `/twitterkit.*` | `/twitterkit.specify`, `/twitterkit.plan`, `/twitterkit.tasks` |
| pm-kit | `/pmkit.*` | `/pmkit.specify`, `/pmkit.plan`, `/pmkit.tasks` |
| pd-kit | `/pdkit.*` | `/pdkit.specify`, `/pdkit.plan`, `/pdkit.tasks` |

**Benefits:**
- AI agents can unambiguously route commands
- Multiple kit commands available simultaneously in same project
- Clear domain context (e.g., `/twitterkit.plan` for Twitter marketing plan)

### 1.3 Coexistence Example

**Scenario**: A project using both spec-kit (for engineering) and twitter-kit (for marketing)

```
my-ai-saas-product/
â”œâ”€â”€ .specify/                    # spec-kit package
â”‚   â”œâ”€â”€ memory/constitution.md   # Engineering principles
â”‚   â”œâ”€â”€ scripts/                 # Engineering workflow scripts
â”‚   â””â”€â”€ templates/               # Code templates
â”‚
â”œâ”€â”€ .twitterkit/                 # twitter-kit package
â”‚   â”œâ”€â”€ memory/constitution.md   # Twitter marketing principles
â”‚   â”œâ”€â”€ scripts/                 # Marketing workflow scripts
â”‚   â””â”€â”€ templates/               # Marketing templates
â”‚
â”œâ”€â”€ .claude/commands/            # Shared agent commands
â”‚   â”œâ”€â”€ speckit.specify.md       # Engineering spec generation
â”‚   â”œâ”€â”€ speckit.plan.md          # Engineering planning
â”‚   â”œâ”€â”€ twitterkit.specify.md    # Marketing spec generation
â”‚   â””â”€â”€ twitterkit.plan.md       # Marketing planning
â”‚
â”œâ”€â”€ specs/                       # All specs (both engineering and marketing)
â”‚   â”œâ”€â”€ 001-user-authentication/ # Engineering feature
â”‚   â”‚   â”œâ”€â”€ spec.md (generated by /speckit.specify)
â”‚   â”‚   â””â”€â”€ plan.md (generated by /speckit.plan)
â”‚   â””â”€â”€ 002-launch-campaign/     # Marketing campaign
â”‚       â”œâ”€â”€ spec.md (generated by /twitterkit.specify)
â”‚       â””â”€â”€ plan.md (generated by /twitterkit.plan)
â”‚
â””â”€â”€ pyproject.toml               # Project config
```

**Workflow**:
1. User runs `specify init .` â†’ Installs .specify/ package
2. User runs `twitterify init .` â†’ Installs .twitterkit/ package (no conflict)
3. User runs `/speckit.specify` for engineering feature
4. User runs `/twitterkit.specify` for marketing campaign
5. Both workflows coexist without interference

### 1.4 Validation Tests

To ensure coexistence, we validate:

1. **Folder Isolation**: `.specify/` and `.twitterkit/` can exist side-by-side
2. **CLI Isolation**: `specify --version` and `twitterify --version` both work
3. **Command Isolation**: `/speckit.plan` and `/twitterkit.plan` trigger correct workflows
4. **Memory Isolation**: Each kit's constitution is independently editable

---

## 2. CLI Naming Strategy

### 2.1 Command Naming Patterns

We follow a consistent pattern for all kit variants:

**Pattern**: `{domain}ify`

**Rationale**:
- **Memorable**: Easy to recall and type
- **Consistent**: All kits follow same pattern
- **Semantic**: Implies "making something happen in this domain"
- **Available**: Most `*ify` names are available on PyPI

**Examples**:
- `specify` â†’ Spec-driven development (original)
- `twitterify` â†’ Twitter marketing operations
- `pmify` â†’ Product management workflows
- `pdify` â†’ Product design workflows
- `blogify` â†’ Blogging/content operations

### 2.2 Alternative Patterns Considered

| Pattern | Example | Pros | Cons | Decision |
|---------|---------|------|------|----------|
| `{domain}-kit` | `twitter-kit` | Clear domain | Hyphen awkward in CLI | âŒ Rejected |
| `kit-{domain}` | `kit-twitter` | Consistent prefix | Less domain-focused | âŒ Rejected |
| `{domain}ify` | `twitterify` | Memorable, semantic | Requires PyPI check | âœ… **ADOPTED** |
| `{domain}spec` | `twitterspec` | Spec-focused | Too narrow (not just specs) | âŒ Rejected |

---

## 3. Slash Command Namespacing

### 3.1 Command Structure

**Format**: `/{kitname}.{workflow}`

**Examples**:
- `/twitterkit.constitution` â†’ Generate Twitter marketing constitution
- `/twitterkit.specify` â†’ Generate Twitter marketing spec
- `/twitterkit.plan` â†’ Generate Twitter growth plan
- `/twitterkit.tasks` â†’ Generate Twitter execution tasks
- `/twitterkit.implement` â†’ Execute Twitter campaign tasks

**Rationale**:
- **Unambiguous**: Agent knows exactly which kit to invoke
- **Discoverable**: Typing `/` shows all available commands grouped by kit
- **Extensible**: New kits can add commands without conflicts

### 3.2 Command File Location

**Convention**: `.claude/commands/{kitname}.{workflow}.md`

**Example**:
```
.claude/commands/
â”œâ”€â”€ speckit.specify.md           # Engineering workflows
â”œâ”€â”€ speckit.plan.md
â”œâ”€â”€ speckit.tasks.md
â”œâ”€â”€ twitterkit.specify.md        # Marketing workflows
â”œâ”€â”€ twitterkit.plan.md
â”œâ”€â”€ twitterkit.tasks.md
â”œâ”€â”€ pmkit.specify.md             # PM workflows
â””â”€â”€ pmkit.plan.md
```

**Benefits**:
- All commands in one location (easy discovery)
- Clear ownership (filename indicates kit)
- Agent-agnostic (works with Claude Code, Cursor, Windsurf, etc.)

---

## 4. Template Transformation Methodology

### 4.1 Systematic Adaptation Process

To transform spec-kit templates for twitter-kit (or any kit):

**Step 1**: Identify domain mappings
- User stories â†’ Campaign objectives
- Technical requirements â†’ Channel strategies
- Code files â†’ Social media posts
- Tests â†’ Success metrics

**Step 2**: Replace section headers
- "Implementation Tasks" â†’ "Twitter Execution Tasks"
- "Architecture" â†’ "Twitter Sprint Cycle"
- "Acceptance Criteria" â†’ "Success Metrics"

**Step 3**: Update variable names
- `$USER_PERSONA` â†’ `$TWITTER_PERSONA`
- `$TECH_STACK` â†’ `$CHANNELS`
- `$ACCEPTANCE_CRITERIA` â†’ `$SUCCESS_METRICS`

**Step 4**: Rewrite example content
- Engineering examples â†’ Domain-specific examples
- Code snippets â†’ Domain-appropriate artifacts

**Step 5**: Ground in domain evidence
- Link to case studies (Cursor, Runway, HeyGen for Twitter)
- Reference best practices from refs/ research
- Cite specific tactics and outcomes

### 4.2 Template Mapping Table

| Spec-Kit Template | Twitter-Kit Template | Generalization |
|-------------------|----------------------|----------------|
| spec-template.md | spec-template.md | Campaign objectives, personas, success metrics |
| plan-template.md | plan-template.md | Sprint cycles, growth loops, experiment log |
| tasks-template.md | tasks-template.md | Execution phases, ownership, checkpoints |

**Key Insight**: The *structure* is reusable (spec â†’ plan â†’ tasks), but the *content* is domain-adapted.

---

## 5. Evidence Base for Twitter Templates

### 5.1 Case Study Sources (2023-2025)

All twitter-kit templates ground their guidance in these sources:

**Primary Case Studies**:
1. **Cursor AI**: Founder-led Twitter, demo-driven content, $300M ARR trajectory
2. **Runway ML**: Build-in-public approach, visual demos, community-driven growth
3. **HeyGen**: Video-first content, viral artifact sharing, product-led growth
4. **Claude Code**: Technical founder voice, methodical product updates
5. **Harvey AI**: Professional positioning, case study sharing, targeted audience

**Reference Documents**:
- `refs/0_overview.md`: Twitter marketing landscape for AI SaaS
- `refs/1_principles_for_constitution.md`: Distilled principles from case studies
- `refs/2_define_for_specify.md`: Spec template adaptation for Twitter domain
- `refs/3_project_mangement_for_plan.md`: Plan template for Twitter growth
- `refs/4_pm_tasking_for_tasks.md`: Task execution for Twitter operations

### 5.2 Template Quality Standards

Every template section must:
- **Cite evidence**: Link to case study or tactic
- **Be actionable**: User knows what to fill in
- **Be measurable**: Success criteria are concrete
- **Be timely**: Grounded in 2023-2025 practices (not outdated advice)

---

## 6. Fork Maintenance Strategy

### 6.1 Selective Merging Approach

twitter-init-kit is a fork of spec-kit. We selectively merge:

**Adopt (Infrastructure Improvements)**:
- CLI bug fixes and enhancements
- Agent integration improvements (new agents, better compatibility)
- Template rendering engine improvements
- Multi-kit coexistence enhancements

**Reject (Domain-Specific Changes)**:
- Engineering-specific template content
- Software development workflows
- Code-focused examples and guidance

### 6.2 Layer Separation

**Portable Infrastructure** (merge from spec-kit):
- `src/{kit}_cli/` (CLI framework)
- `.claude/commands/` (agent integration pattern)
- `scripts/bash/` (workflow automation pattern)

**Domain Layer** (twitter-kit specific):
- `.twitterkit/templates/` (Twitter marketing content)
- `.twitterkit/memory/constitution.md` (Twitter principles)
- `refs/` (Twitter case study research)

### 6.3 Merge Process

1. **Monthly Review**: Check spec-kit releases for infrastructure improvements
2. **Quarterly Merge**: Adopt relevant improvements, test coexistence
3. **Document Changes**: Update research.md with merge decisions
4. **Validate**: Run multi-kit coexistence tests after merge

---

## 7. Python Package Naming

### 7.1 PyPI Package Names

**Pattern**: `{domain}ify-cli`

| Kit | PyPI Package | Python Module |
|-----|--------------|---------------|
| spec-kit | `specify-cli` | `specify_cli` |
| twitter-kit | `twitterify-cli` | `twitterify_cli` |
| pm-kit | `pmify-cli` | `pmify_cli` |
| pd-kit | `pdify-cli` | `pdify_cli` |

**Rationale**:
- **Descriptive**: `*-cli` suffix indicates command-line tool
- **Available**: Less likely to conflict on PyPI
- **Consistent**: All kits follow same pattern

### 7.2 Installation Pattern

**Recommended**:
```bash
uv tool install twitterify-cli --from git+https://github.com/{org}/twitter-init-kit.git
```

**Why `uv tool install`**:
- Global installation (available in PATH)
- Isolated environment per tool
- Easy upgrade: `uv tool install --force ...`
- Better than aliases or shell functions

---

## 8. Decision Log

| Date | Decision | Rationale | Status |
|------|----------|-----------|--------|
| 2025-12-04 | Adopt three-level namespace isolation | Enables multi-kit coexistence | âœ… Implemented |
| 2025-12-04 | CLI naming: `{domain}ify` pattern | Memorable, consistent, available | âœ… Implemented |
| 2025-12-04 | Slash commands: `/{kitname}.{workflow}` | Unambiguous routing, extensible | âœ… Implemented |
| 2025-12-04 | Package folders: `.{kitname}/` | Clear separation, git-friendly | âœ… Implemented |
| 2025-12-04 | Selective fork maintenance | Merge infrastructure, not domain content | ğŸ“‹ Documented |

---

## 9. Open Questions & Future Research

### 9.1 Unresolved Questions

1. **Kit Registry**: Should we build a central registry for discovering available kits?
2. **Kit Dependencies**: Can one kit depend on another (e.g., marketing-kit depends on twitter-kit)?
3. **Shared Constitution**: Should kits share a common constitution or always have separate ones?
4. **Cross-Kit Workflows**: How to coordinate workflows across kits (e.g., product launch uses both spec-kit and twitter-kit)?

### 9.2 Future Experiments

- **Test pm-kit creation**: Validate that template transformation process is truly reusable
- **Test pd-kit creation**: Verify design domain adapts well to spec-driven methodology
- **Multi-kit project**: Build a real project using 3+ kits simultaneously
- **Community feedback**: Get 5+ teams to fork and create their own kit variants

---

**Status**: Research complete, architecture validated, ready for implementation
**Next**: Proceed with Phase 2 (CLI Implementation) and Phase 3 (Template Adaptation)
